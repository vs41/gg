<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>WebRTC Audio Only Demo</title>
    <style>
      body { font-family: sans-serif; margin: 20px; }
      audio { display: block; margin-bottom: 10px; }
      .remote-audio-item { margin-bottom: 20px; }
      #logs { background: #f5f5f5; padding: 10px; border: 1px solid #ccc; height: 200px; overflow-y: auto; }
    </style>
  </head>
  <body>
    <main>
      <h2>WebRTC Audio Only Demo</h2>

      <section>
        <h3>Local Audio</h3>
        <audio id="localAudio" autoplay muted controls></audio>
      </section>

      <section>
        <h3>Remote Audio</h3>
        <div id="remoteAudios"></div>
      </section>

      <section>
        <h3>Logs</h3>
        <div id="logs"></div>
      </section>
    </main>

    <script>
      const log = (msg) => {
        console.log(msg);
        const div = document.getElementById("logs");
        div.innerHTML += msg + "<br>";
        div.scrollTop = div.scrollHeight;
      };

      // ðŸ”¹ Extract username from WebSocket URL
      const wsURL = "{{.}}";
      const urlParams = new URLSearchParams(wsURL.split('?')[1]);
      const currentUsername = urlParams.get('username') || "Unknown";
      log("Your username: " + currentUsername);

      const remoteUsers = {};          // track.id -> {element, label}
      const pendingNames = new Set();  // usernames waiting for a track

      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => {
          document.getElementById("localAudio").srcObject = stream;

          const pc = new RTCPeerConnection();

          // Add local audio
          stream.getTracks().forEach(track => pc.addTrack(track, stream));

          // When remote tracks arrive
          pc.ontrack = (event) => {
            if (event.track.kind !== "audio") return;
            const el = document.createElement("audio");
            el.srcObject = event.streams[0];
            el.autoplay = true;
            el.controls = true;

            const container = document.createElement("div");
            container.className = "remote-audio-item";

            const nameLabel = document.createElement("p");
            nameLabel.textContent = "ðŸŽ¤ Unknown user";
            nameLabel.style.fontWeight = "bold";

            container.appendChild(nameLabel);
            container.appendChild(el);
            document.getElementById("remoteAudios").appendChild(container);

            remoteUsers[event.track.id] = { element: container, nameLabel };
            log(`ðŸŽ§ New remote track added (id: ${event.track.id})`);

            // If we have pending names, assign them now
            if (pendingNames.size > 0) {
              const nextName = pendingNames.values().next().value;
              pendingNames.delete(nextName);
              nameLabel.textContent = `ðŸŽ¤ ${nextName}`;
              log(`âœ… Assigned queued name ${nextName} to new track`);
            }

            event.streams[0].onremovetrack = ({ track }) => {
              if (container.parentNode) container.parentNode.removeChild(container);
              delete remoteUsers[track.id];
            };
          };

          // Connect WebSocket
          const ws = new WebSocket(wsURL);

          ws.onopen = () => log("WebSocket connected âœ…");
          ws.onclose = () => log("WebSocket disconnected âŒ");
          ws.onerror = (evt) => log("WebSocket error: " + evt.data);

          // ICE candidate handler
          pc.onicecandidate = (e) => {
            if (e.candidate && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                event: "candidate",
                data: JSON.stringify(e.candidate)
              }));
            }
          };

          ws.onmessage = (evt) => {
            let msg;
            try {
              msg = JSON.parse(evt.data);
            } catch (err) {
              return log("Failed to parse message: " + evt.data);
            }

            switch (msg.event) {
              case "offer": {
                const offer = JSON.parse(msg.data);
                const username = msg.user || "Unknown";
                log(`ðŸ“¨ Received offer from ${username}`);
                console.log("currentUsername", currentUsername, "username", username);

                if (username === currentUsername) {
                  log("â†©ï¸ Offer is from yourself â€” skipping label update");
                } else {
                  // Label remote audio or queue username if no track yet
                  let labeled = false;
                  for (const trackId in remoteUsers) {
                    const user = remoteUsers[trackId];
                    if (user.nameLabel.textContent === "ðŸŽ¤ Unknown user") {
                      user.nameLabel.textContent = `ðŸŽ¤ ${username}`;
                      labeled = true;
                      log(`âœ… Labeled remote track as ${username}`);
                      break;
                    }
                  }

                  if (!labeled) {
                    pendingNames.add(username);
                    log(`ðŸ•“ No available track for ${username}, queued name`);
                  }
                }

                pc.setRemoteDescription(offer)
                  .then(() => pc.createAnswer())
                  .then(answer => {
                    pc.setLocalDescription(answer);
                    if (ws.readyState === WebSocket.OPEN) {
                      ws.send(JSON.stringify({
                        event: "answer",
                        data: JSON.stringify(answer)
                      }));
                    }
                    log(`âœ… Sent answer to ${username}`);
                  })
                  .catch(err => log("Error handling offer: " + err));
                break;
              }

              case "candidate": {
                const candidate = JSON.parse(msg.data);
                pc.addIceCandidate(candidate).catch(err => log("ICE add error: " + err));
                break;
              }

              default:
                log("Unknown event: " + msg.event);
            }
          };
        })
        .catch(err => {
          alert("Microphone error: " + err);
          log("Microphone error: " + err);
        });
    </script>
  </body>
</html>
